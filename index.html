<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>사랑방 띵곡 플레이어</title>
  <style>
    body { font-family: system-ui, -apple-apple-system, Segoe UI, Roboto, sans-serif; background: #111; color: #eee; margin: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
    .wrap { max-width: 900px; margin: 24px auto; padding: 0 16px; width: 100%; }
    .card { border: 1px solid #444; border-radius: 10px; padding: 16px; margin: 12px 0; background: #222; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
    .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .btn { background: #63b3ed; color: #fff; border: 0; border-radius: 999px; padding: .6rem 1rem; cursor: pointer; transition: background 0.2s; }
    .btn:hover { background: #4299e1; }
    .btn:disabled { background: #4a5568; cursor: not-allowed; }
    .btn-toggle { background: #555; }
    .btn-toggle.active { background: #fc8181; } /* 버스터콜 활성화 시 빨간색 */
    .ok { color: #81e6d9; }
    .fail { color: #fc8181; }
    .muted { color: #a0aec0; }
    input { background: #1f2937; color: #eee; border: 1px solid #374151; border-radius: 8px; padding: .55rem .7rem; flex: 1; min-width: 220px; outline: none; transition: border-color 0.2s; }
    input:focus { border-color: #63b3ed; }
    .item { display: flex; justify-content: space-between; align-items: center; padding: .5rem .6rem; border-bottom: 1px solid #2f3743; cursor: pointer; transition: background 0.2s; }
    .item:hover { background: #2a3340; }
    .item:last-child { border-bottom: none; }
    .item .delete-btn { background: none; border: none; color: #fc8181; cursor: pointer; font-size: 1.2em; line-height: 1; margin-left: 10px; opacity: 0.7; transition: opacity 0.2s; }
    .item .delete-btn:hover { opacity: 1; }
    .item .info-icon { background: none; border: none; color: #63b3ed; cursor: pointer; font-size: 0.6em; margin-right: 5px; }
    .video-player { aspect-ratio: 16 / 9; width: 100%; max-width: 800px; margin: 8px auto; border-radius: 8px; overflow: hidden; position: relative; }
    .main-title { text-align: center; }
    .sub-title { text-align: center; font-size: 0.9em; margin-top: -15px; color: #a0aec0; }
    .message-box { display: none; background: #2d3748; color: #fff; padding: 12px; border-radius: 8px; text-align: center; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000; }
    #player { height: 100%; width: 100%; }
    .player-controls { display: none; } /* 유튜브 화면 위에 있는 버튼을 숨김 */
    
    /* Info modal */
    .modal { display: none; position: fixed; z-index: 1001; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4); justify-content: center; align-items: center; }
    .modal-content { background-color: #222; padding: 20px; border: 1px solid #444; width: 80%; max-width: 500px; border-radius: 10px; position: relative; }
    .modal-content .modal-section { margin-bottom: 15px; }
    .modal-content .modal-section label { display: block; margin-bottom: 5px; font-weight: bold; }
    .modal-content input[type="text"], .modal-content textarea { width: 100%; box-sizing: border-box; background: #1f2937; color: #eee; border: 1px solid #374151; border-radius: 8px; padding: 10px; outline: none; }
    .modal-content textarea { height: 100px; resize: vertical; }
    .modal-content .close-btn { color: #aaa; float: right; font-size: 28px; font-weight: bold; }
    .modal-content .close-btn:hover, .modal-content .close-btn:focus { color: #fff; text-decoration: none; cursor: pointer; }
    .modal-content .save-btn { background: #38b2ac; color: #fff; border: 0; border-radius: 999px; padding: .6rem 1rem; margin-top: 10px; cursor: pointer; }

    /* Custom Confirmation Modal */
    .confirm-modal { display: none; position: fixed; z-index: 1002; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4); justify-content: center; align-items: center; }
    .confirm-modal-content { background-color: #222; padding: 20px; border: 1px solid #444; width: 80%; max-width: 350px; border-radius: 10px; text-align: center; }
    .confirm-modal-content p { margin: 0 0 20px 0; }
    .confirm-modal-buttons { display: flex; justify-content: space-around; }
    .confirm-modal-buttons .btn { min-width: 100px; }

    /* Current Song Info Display */
    #currentSongNotes {
        border-top: 1px solid #444;
        margin-top: 10px;
        padding-top: 10px;
    }
    #currentSongNotes h4 {
        margin: 0;
        margin-bottom: 5px;
        color: #63b3ed;
    }
    #currentSongNotes p {
        margin: 0;
        margin-bottom: 10px;
        color: #ccc;
    }
    .song-details {
      flex: 1;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }
    /* Buster Call Overlay */
    .buster-call-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        color: #fff;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        z-index: 999;
        transition: opacity 0.5s ease-in-out;
        opacity: 0;
        pointer-events: none; /* Allows clicks to pass through when hidden */
    }
    .buster-call-overlay.show {
        opacity: 1;
    }
    .buster-call-overlay h2 {
        font-size: 3em;
        margin: 0;
        animation: pulse 1s infinite;
    }
    .buster-call-overlay p {
        font-size: 1.5em;
        margin: 0;
    }
    @keyframes pulse {
        0% {
            transform: scale(1);
        }
        50% {
            transform: scale(1.05);
        }
        100% {
            transform: scale(1);
        }
    }
    /* New styles for one-line song info and buttons */
    .song-info-container {
      display: flex;
      align-items: center;
      justify-content: center; /* Center horizontally */
      margin-top: 10px;
      gap: 10px;
      font-size: 1.2em;
      font-weight: bold;
      text-align: center; /* For the text inside */
    }
    .song-info-text {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: calc(100% - 120px); /* Adjust based on button width */
    }
    /* New style for the info button */
    .current-info-btn {
      background: none;
      border: none;
      color: #63b3ed;
      cursor: pointer;
      /* 아이콘 크기 절반으로 줄임 */
      font-size: 0.8em;
      margin-right: 5px;
      padding: 0;
    }
  </style>
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore-compat.js"></script>
  <!-- YouTube iFrame Player API -->
  <script src="https://www.youtube.com/iframe_api"></script>
</head>
<body>
<div id="message-box" class="message-box"></div>
<div class="wrap">
  <div class="main-title">
    <h1>사랑방 띵곡 플레이어</h1>
    <p class="sub-title">작가님들의 띵곡을 추천해주세요</p>
  </div>
  
  <div class="card">
    <div id="player-container" class="video-player">
      <div id="player"></div>
      <div class="player-controls">
        <button id="prev-song-btn" class="prev">&lt;</button>
        <button id="next-song-btn" class="next">&gt;</button>
      </div>
      <div id="buster-call-overlay" class="buster-call-overlay">
        <h2>버스터콜!!!</h2>
        <p>모두집중!!!</p>
      </div>
    </div>
    
    <div class="song-info-container">
      <button id="prev-song-btn-inline" class="btn">&lt;</button>
      <div id="currentSongInfo" class="song-info-text">
        <span class="muted">현재 재생 중인 곡이 없습니다.</span>
      </div>
      <button id="next-song-btn-inline" class="btn">&gt;</button>
    </div>

    <div id="currentSongNotes">
      <span class="muted"></span>
    </div>

    <!-- Combined input and button row -->
    <div class="row" style="margin-top:10px">
      <input id="url" placeholder="유튜브 링크 또는 ID를 붙여넣기"/>
      <button id="add" class="btn">추가</button>
      <button id="shuffleBtn" class="btn">셔플</button>
      <button id="togglePlayerBtn" class="btn">화면 숨기기</button>
      <button id="busterCallToggle" class="btn btn-toggle">버스터콜</button>
    </div>
    
    <div id="manual-input" style="display:none; margin-top: 10px;">
      <div class="row">
        <input id="manualTitle" placeholder="제목을 수동으로 입력해주세요"/>
      </div>
      <div class="row" style="margin-top: 10px;">
        <input id="manualArtist" placeholder="아티스트를 수동으로 입력해주세요"/>
      </div>
    </div>

    <div id="playlist" class="card" style="margin:10px 0 0 0">
      <div class="muted">재생목록이 비어있습니다.</div>
    </div>
  </div>
</div>

<!-- Info Modal -->
<div id="infoModal" class="modal">
  <div class="modal-content">
    <span class="close-btn">&times;</span>
    <h3>노래 정보</h3>
    <div class="modal-section">
      <label for="songTitleInput">노래 제목</label>
      <input type="text" id="songTitleInput" placeholder="노래 제목을 입력하세요..."/>
    </div>
    <div class="modal-section">
      <label for="artistInput">아티스트</label>
      <input type="text" id="artistInput" placeholder="아티스트 이름을 입력하세요..."/>
    </div>
    <div class="modal-section">
      <label for="uploaderInput">올린 사람</label>
      <input type="text" id="uploaderInput" placeholder="이름을 입력하세요..."/>
    </div>
    <div class="modal-section">
      <label for="infoTextarea">노래에 대한 정보</label>
      <textarea id="infoTextarea" placeholder="노트에 메모를 입력하세요..."></textarea>
    </div>
    <div class="modal-section">
      <label for="commentTextarea">댓글</label>
      <textarea id="commentTextarea" placeholder="댓글을 입력하세요..."></textarea>
    </div>
    <button id="saveInfoBtn" class="save-btn">저장</button>
  </div>
</div>

<!-- Custom Confirmation Modal -->
<div id="confirmModal" class="confirm-modal">
  <div class="confirm-modal-content">
    <p>정말로 삭제하시겠습니까?</p>
    <div class="confirm-modal-buttons">
      <button id="confirmYes" class="btn">예</button>
      <button id="confirmNo" class="btn btn-toggle">아니오</button>
    </div>
  </div>
</div>

<script>
  // --- IMPORTANT: YouTube API Key ---
  // This error occurs when the API key usage is exceeded or the key is invalid.
  // If you have your own API key, please replace the value of the variable below.
  // https://console.cloud.google.com/apis/credentials
  const YOUTUBE_API_KEY = "AIzaSyB2GymrywkBYx4Mbt_xHNiYEV44MbfKY2w";
  
  // Firebase configuration
  const firebaseConfig = {
    apiKey: "AIzaSyDz6xGJNKXinG5rREjdrPz7toIYGZXzilU",
    authDomain: "sarangbangmusicplaylist.firebaseapp.com",
    projectId: "sarangbangmusicplaylist",
    storageBucket: "sarangbangmusicplaylist.apppt.com",
    messagingSenderId: "193412502606",
    appId: "1:193412502606:web:0f7f9ddbef1ee6711d1ff",
    measurementId: "G-L14GH3BHYD"
  };

  // ----- elements -----
  const urlInput = document.getElementById('url');
  const addBtn = document.getElementById('add');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const listEl = document.getElementById('playlist');
  const messageBox = document.getElementById('message-box');
  const manualInputDiv = document.getElementById('manual-input');
  const manualTitleInput = document.getElementById('manualTitle');
  const manualArtistInput = document.getElementById('manualArtist');
  const busterCallToggleBtn = document.getElementById('busterCallToggle');
  const prevSongBtn = document.getElementById('prev-song-btn-inline');
  const nextSongBtn = document.getElementById('next-song-btn-inline');
  const currentSongInfoEl = document.getElementById('currentSongInfo');
  const currentSongNotesEl = document.getElementById('currentSongNotes');
  const busterCallOverlay = document.getElementById('buster-call-overlay');
  const togglePlayerBtn = document.getElementById('togglePlayerBtn');
  const playerContainer = document.getElementById('player-container');

  // Info modal elements
  const infoModal = document.getElementById('infoModal');
  const songTitleInput = document.getElementById('songTitleInput');
  const artistInput = document.getElementById('artistInput');
  const uploaderInput = document.getElementById('uploaderInput');
  const infoTextarea = document.getElementById('infoTextarea');
  const commentTextarea = document.getElementById('commentTextarea');
  const saveInfoBtn = document.getElementById('saveInfoBtn');
  const modalCloseBtn = document.querySelector('.modal .close-btn');
  let currentInfoVideoId = null;

  // Custom confirmation modal elements
  const confirmModal = document.getElementById('confirmModal');
  const confirmYesBtn = document.getElementById('confirmYes');
  const confirmNoBtn = document.getElementById('confirmNo');

  // ----- state/guards -----
  const appId = 'default-app-id';
  const clientId = (crypto && crypto.randomUUID) ? crypto.randomUUID() : String(Math.random());
  let userId = null;
  
  // Centralized state management
  const globalState = {
    playlist: [], // Firestore에서 가져온 아티스트 이름 순으로 정렬된 원본 리스트
    shuffledPlaylist: [], // 각 사용자의 셔플된 리스트
    isShuffled: false,
    videoId: '',
    timestamp: 0,
    lastUpdatedBy: null,
    currentPlayingIndex: -1,
    isBusterCallMode: false,
    lastBusterCallTimestamp: 0,
    busterCallCoolDown: 30 * 1000, // 30초
    isPlayerVisible: true
  };

  let authed = false;
  let player;
  let playerReady = false;
  let isManuallyAdding = false;

  function showMessage(message, type = 'info') {
    messageBox.textContent = message;
    if (type === 'error') {
      messageBox.style.background = '#fc8181';
    } else {
      messageBox.style.background = '#2d3748';
    }
    messageBox.style.display = 'block';
    setTimeout(() => {
      messageBox.style.display = 'none';
    }, 3000);
  }

  function showConfirm(message, onConfirm) {
    document.querySelector('#confirmModal p').textContent = message;
    confirmModal.style.display = 'flex';
    return new Promise((resolve) => {
      confirmYesBtn.onclick = () => {
        confirmModal.style.display = 'none';
        resolve(true);
      };
      confirmNoBtn.onclick = () => {
        confirmModal.style.display = 'none';
        resolve(false);
      };
    });
  }

  // ----- Firebase initialization + anonymous login + diagnostics -----
  async function boot() {
    try {
      firebase.initializeApp(firebaseConfig);
      console.log("Firebase initialized successfully");
    } catch (e) {
      console.error("Firebase initialization failed: " + e.message);
      return;
    }

    try {
      await firebase.auth().signInAnonymously();
      authed = true;
      userId = firebase.auth().currentUser.uid;
      console.log("Anonymous sign-in successful, user ID:", userId);
    } catch (e) {
      console.error("Authentication failed: " + e.message);
      return;
    }

    // Firestore ping
    const db = firebase.firestore();
    try {
      const pingRef = db.collection('artifacts').doc(appId).collection('public').doc('_ping');
      await pingRef.set({ pong: true, by: clientId, at: new Date() }, { merge: true });
      console.log("Firestore write successful");
    } catch (e) {
      console.error("Firestore write failed: " + e.message);
    }

    startRealtime();
    wireUI();
  }
  
  // Called when the YouTube iFrame Player API is loaded
  function onYouTubeIframeAPIReady() {
    playerReady = true;
    player = new YT.Player('player', {
      height: '100%',
      width: '100%',
      videoId: '',
      playerVars: {
        'autoplay': 0, 
        'controls': 1,
        'disablekb': 1,
        'fs': 0,
        'iv_load_policy': 3,
        'modestbranding': 1,
        'rel': 0,
        'showinfo': 0
      },
      events: {
        'onStateChange': onPlayerStateChange,
        'onReady': onPlayerReady
      }
    });
  }
  
  // Called when the YouTube player is ready
  function onPlayerReady(event) {
    console.log('YouTube Player is ready.');
  }

  // Called when the YouTube player state changes
  function onPlayerStateChange(event) {
    console.log('Player state changed:', event.data);
    switch (event.data) {
        case YT.PlayerState.ENDED:
            playNext(); // 다음 곡 재생
            break;
        case YT.PlayerState.PLAYING:
            const currentVideoId = player.getVideoData().video_id;
            if (currentVideoId && currentVideoId.length === 11) {
                updatePlayingSong(currentVideoId);
            }
            break;
        case YT.PlayerState.PAUSED:
            globalState.timestamp = player.getCurrentTime();
            break;
    }
  }

  // 버스터콜 상태를 저장하는 함수
  function saveBusterCallState() {
      if (!authed) return;
      const db = firebase.firestore();
      const ref = db.collection('artifacts').doc(appId).collection('public')
          .doc('data').collection('buster_call_state').doc('main_state');
      
      ref.set({
          lastBusterCallTimestamp: firebase.firestore.FieldValue.serverTimestamp(),
          updatedBy: clientId,
      }, { merge: true }).then(() => {
          console.log('Buster call state saved.');
      }).catch(e => {
          console.error('Failed to save buster call state:', e);
      });
  }

  function startRealtime() {
    const db = firebase.firestore();

    // 버스터콜 상태 실시간 동기화
    const busterCallRef = db.collection('artifacts').doc(appId).collection('public')
        .doc('data').collection('buster_call_state').doc('main_state');
    
    busterCallRef.onSnapshot(snap => {
        if (!snap.exists) return;
        const state = snap.data();
        if (state && state.lastBusterCallTimestamp) {
            globalState.lastBusterCallTimestamp = state.lastBusterCallTimestamp.toMillis();
            checkBusterCallCooldown();
        }
    }, err => {
        console.error("Buster call state subscription error:", err);
    });

    // 재생 상태 실시간 동기화
    const playbackRef = db.collection('artifacts').doc(appId).collection('public')
      .doc('data').collection('playback_state').doc('main_state');
    
    playbackRef.onSnapshot(async (snap) => {
      if (!snap.exists) return;
      const state = snap.data() || {};
      
      if (state.lastUpdatedBy === clientId) return;

      try {
        if (playerReady && state.videoId && globalState.videoId !== state.videoId) {
            player.loadVideoById(state.videoId);
            player.seekTo(state.timestamp, true);
        }
      } catch (e) {
        console.error("Playback sync error:", e);
      }
    }, (err) => { console.error("Playback subscription error: " + err.message); });

    // 재생 목록 실시간 동기화 (Firestore에서 아티스트 이름 순으로 정렬하여 가져옴)
    const playlistRef = db.collection('artifacts').doc(appId).collection('public')
      .doc('data').collection('playlist_state').doc('main_playlist');

    playlistRef.onSnapshot(async (snap) => {
      if (!snap.exists) {
        savePlaylistState();
        return;
      }
      const playlistData = snap.data() || {};
      
      // Firestore에서 가져온 재생목록을 아티스트 이름 순으로 정렬
      const sortedPlaylist = Array.isArray(playlistData.playlist) ? playlistData.playlist.sort((a, b) => {
        const artistA = a.artist.toLowerCase();
        const artistB = b.artist.toLowerCase();
        if (artistA < artistB) return -1;
        if (artistA > artistB) return 1;
        return 0;
      }) : [];
      
      globalState.playlist = sortedPlaylist;
      
      // 셔플 상태에 따라 리스트 업데이트
      if (globalState.isShuffled) {
        // 기존 셔플 리스트가 있으면 그대로 사용
        const localStorageKey = `shuffledPlaylist_${userId}`;
        const storedShuffled = localStorage.getItem(localStorageKey);
        if (storedShuffled) {
          try {
            const parsedShuffled = JSON.parse(storedShuffled);
            // 저장된 셔플 리스트가 현재 플레이리스트와 동일한지 확인
            if (parsedShuffled.length === globalState.playlist.length &&
                parsedShuffled.every(s => globalState.playlist.some(p => p.videoId === s.videoId))) {
              globalState.shuffledPlaylist = parsedShuffled;
            } else {
              // 리스트가 변경되었으면 새로 셔플
              globalState.shuffledPlaylist = [...globalState.playlist].sort(() => Math.random() - 0.5);
              localStorage.setItem(localStorageKey, JSON.stringify(globalState.shuffledPlaylist));
            }
          } catch (e) {
            // JSON 파싱 에러 시 새로 셔플
            globalState.shuffledPlaylist = [...globalState.playlist].sort(() => Math.random() - 0.5);
            localStorage.setItem(localStorageKey, JSON.stringify(globalState.shuffledPlaylist));
          }
        } else {
          globalState.shuffledPlaylist = [...globalState.playlist].sort(() => Math.random() - 0.5);
          localStorage.setItem(localStorageKey, JSON.stringify(globalState.shuffledPlaylist));
        }
      } else {
        globalState.shuffledPlaylist = [];
      }

      renderList();
      // 재생목록이 업데이트될 때 현재 재생 중인 곡 정보도 갱신
      if (player && player.getPlayerState() === YT.PlayerState.PLAYING) {
        updatePlayingSong(player.getVideoData().video_id);
      }
    }, (err) => { console.error("Playlist subscription error: " + err.message); });

    // 현재 재생 중인 곡의 노트 정보 실시간 동기화
    const notesRef = db.collection('artifacts').doc(appId).collection('users').doc(userId).collection('notes');
    notesRef.onSnapshot(async (snap) => {
        renderCurrentSongNotes();
    }, (err) => { console.error("Notes subscription error: " + err.message); });
  }

  // Updates the playlist in the global state and triggers a save
  function updatePlaylist(newPlaylist) {
    globalState.playlist = newPlaylist;
    // Firestore에는 항상 아티스트 이름 순으로 저장
    savePlaylistState();
  }
  
  // 재생목록(playlist)만 저장하는 함수
  let playlistSaveTimer = null;
  function savePlaylistState() {
    if (!authed) return;
    if (playlistSaveTimer) clearTimeout(playlistSaveTimer);
    playlistSaveTimer = setTimeout(async () => {
      try {
        const db = firebase.firestore();
        const ref = db.collection('artifacts').doc(appId).collection('public')
          .doc('data').collection('playlist_state').doc('main_playlist');
        
        // Firestore에 저장할 때는 정렬된 리스트를 사용
        const sortedForFirestore = [...globalState.playlist].sort((a, b) => {
            const artistA = a.artist.toLowerCase();
            const artistB = b.artist.toLowerCase();
            if (artistA < artistB) return -1;
            if (artistA > artistB) return 1;
            return 0;
        });

        await ref.set({
          playlist: sortedForFirestore,
          lastUpdatedBy: clientId,
          updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge: true });

        console.log('Playlist state saved successfully.');
      } catch (e) {
        console.error("Failed to save playlist state: " + e.message);
      }
    }, 300);
  }

  // ----- UI/player -----
  function renderList() {
    listEl.innerHTML = '';
    const playlistToRender = globalState.isShuffled ? globalState.shuffledPlaylist : globalState.playlist;

    if (!playlistToRender.length) {
      listEl.innerHTML = '<div class="muted">재생목록이 비어있습니다.</div>';
      renderCurrentSongInfo();
      return;
    }
    
    playlistToRender.forEach((item, index) => {
      const div = document.createElement('div');
      div.className = 'item';
      div.dataset.videoId = item.videoId;
      div.dataset.index = index; // Store index for later use

      const infoIcon = document.createElement('button');
      infoIcon.className = 'info-icon';
      infoIcon.innerHTML = '&#x24D8;';
      infoIcon.addEventListener('click', (e) => {
        e.stopPropagation();
        openInfoModal(item.videoId);
      });

      const titleSpan = document.createElement('span');
      titleSpan.className = 'song-details';
      titleSpan.textContent = `${item.artist} - ${item.title}`;
      
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'delete-btn';
      deleteBtn.innerHTML = '&#x2715;';
      deleteBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const shouldDelete = await showConfirm("정말로 삭제하시겠습니까?");
        if (shouldDelete) {
            const newPlaylist = [...globalState.playlist];
            const itemIndex = newPlaylist.findIndex(song => song.videoId === item.videoId);
            if (itemIndex > -1) {
                newPlaylist.splice(itemIndex, 1);
                updatePlaylist(newPlaylist);
            }
        }
      });
      
      div.appendChild(infoIcon);
      div.appendChild(titleSpan);
      div.appendChild(deleteBtn);
      
      div.addEventListener('click', () => {
        const videoId = div.dataset.videoId;
        const songIndex = parseInt(div.dataset.index, 10);
        if (globalState.isBusterCallMode) {
          const now = Date.now();
          const lastBusterCall = globalState.lastBusterCallTimestamp;
          
          if (now - lastBusterCall > globalState.busterCallCoolDown) {
            busterCall(videoId);
            globalState.isBusterCallMode = false;
            busterCallToggleBtn.classList.remove('active');
          } else {
            const remaining = Math.ceil((globalState.busterCallCoolDown - (now - lastBusterCall)) / 1000);
            showMessage(`버스터콜은 ${remaining}초 후에 다시 사용할 수 있습니다.`, 'info');
            globalState.isBusterCallMode = false;
            busterCallToggleBtn.classList.remove('active');
          }
        } else {
          playVideo(songIndex);
          showMessage("해당 곡을 재생합니다.");
        }
      });
      
      listEl.appendChild(div);
    });
    
    if (playlistToRender.length > 0 && (!player || !player.getVideoData())) {
        playVideo(0); 
    }
    renderCurrentSongInfo();
  }

  // Helper function to update the current playing song and its information
  function updatePlayingSong(videoId) {
    const playlistToSearch = globalState.isShuffled ? globalState.shuffledPlaylist : globalState.playlist;
    const songIndex = playlistToSearch.findIndex(item => item.videoId === videoId);
    if (songIndex !== -1) {
      globalState.currentPlayingIndex = songIndex;
      globalState.videoId = videoId;
      renderCurrentSongInfo();
    } else {
      // If the song is not in the list, show generic info
      globalState.currentPlayingIndex = -1;
      globalState.videoId = '';
      currentSongInfoEl.innerHTML = '<span class="muted">재생목록에 없는 곡입니다.</span>';
      currentSongNotesEl.innerHTML = '';
    }
  }

  function renderCurrentSongInfo() {
      const playlistToRender = globalState.isShuffled ? globalState.shuffledPlaylist : globalState.playlist;
      const songToDisplay = playlistToRender[globalState.currentPlayingIndex];
      if (songToDisplay) {
          const infoButton = `<button class="current-info-btn" onclick="openInfoModal('${songToDisplay.videoId}')">&#x24D8;</button>`;
          const songText = `<span style="font-weight: bold;">${songToDisplay.title}</span><span class="muted" style="margin-left: 5px;"> - ${songToDisplay.artist}</span>`;
          currentSongInfoEl.innerHTML = infoButton + songText;
          renderCurrentSongNotes();
      } else {
          currentSongInfoEl.innerHTML = '<span class="muted">현재 재생 중인 곡이 없습니다.</span>';
          currentSongNotesEl.innerHTML = '';
      }
  }

  async function renderCurrentSongNotes() {
      currentSongNotesEl.innerHTML = '<span class="muted">정보를 불러오는 중...</span>';
      
      const videoId = globalState.videoId;
      if (!videoId || !userId) {
          currentSongNotesEl.innerHTML = '<span class="muted">작성된 정보가 없습니다.</span>';
          return;
      }

      const db = firebase.firestore();
      const docRef = db.collection('artifacts').doc(appId).collection('users').doc(userId).collection('notes').doc(videoId);
      
      try {
          const docSnap = await docRef.get();
          if (docSnap.exists) {
              const data = docSnap.data();
              const uploader = data.uploader || '알 수 없음';
              const info = data.info || '작성된 정보가 없습니다.';
              const comment = data.comment || '작성된 댓글이 없습니다.';
              
              currentSongNotesEl.innerHTML = `
                  <p><strong>올린 사람:</strong> ${uploader}</p>
                  <p><strong>노래 정보:</strong> ${info}</p>
                  <p><strong>댓글:</strong> ${comment}</p>
              `;
          } else {
              currentSongNotesEl.innerHTML = '<span class="muted">작성된 정보가 없습니다.</span>';
          }
      } catch(e) {
          console.error("Failed to render current song notes:", e);
          currentSongNotesEl.innerHTML = '<span class="muted">정보를 불러오는 데 실패했습니다.</span>';
      }
  }

  function checkBusterCallCooldown() {
      const now = Date.now();
      const cooldownRemaining = globalState.lastBusterCallTimestamp + globalState.busterCallCoolDown - now;
      if (cooldownRemaining > 0) {
          const remainingSeconds = Math.ceil(cooldownRemaining / 1000);
          busterCallToggleBtn.disabled = true;
          busterCallToggleBtn.textContent = `버스터콜 (${remainingSeconds}초)`;
          setTimeout(checkBusterCallCooldown, 1000);
      } else {
          busterCallToggleBtn.disabled = false;
          busterCallToggleBtn.textContent = '버스터콜';
      }
  }

  // Info modal functions
  function openInfoModal(videoId) {
    currentInfoVideoId = videoId;
    const songItem = globalState.playlist.find(item => item.videoId === videoId);
    if (songItem) {
        songTitleInput.value = songItem.title;
        artistInput.value = songItem.artist;
    }

    const db = firebase.firestore();
    const docRef = db.collection('artifacts').doc(appId).collection('users').doc(userId).collection('notes').doc(videoId);
    
    docRef.get().then(docSnap => {
        if (docSnap.exists) {
            const data = docSnap.data();
            uploaderInput.value = data.uploader || '';
            infoTextarea.value = data.info || '';
            commentTextarea.value = data.comment || '';
        } else {
            uploaderInput.value = '';
            infoTextarea.value = '';
            commentTextarea.value = '';
        }
    }).catch(e => {
        console.error("Failed to load note:", e);
        uploaderInput.value = '';
        infoTextarea.value = 'Failed to load note.';
        commentTextarea.value = '';
    });
    
    infoModal.style.display = 'flex';
  }

  function closeInfoModal() {
    infoModal.style.display = 'none';
    currentInfoVideoId = null;
  }

  async function saveInfo() {
    if (!currentInfoVideoId || !authed) return;
    
    const newTitle = songTitleInput.value.trim();
    const newArtist = artistInput.value.trim();
    
    // 1. Update the song title and artist in the main playlist
    const newPlaylist = [...globalState.playlist];
    const songIndex = newPlaylist.findIndex(item => item.videoId === currentInfoVideoId);
    
    if (songIndex !== -1) {
        newPlaylist[songIndex].title = newTitle;
        newPlaylist[songIndex].artist = newArtist;
        updatePlaylist(newPlaylist);
    }
    
    // 2. Save private notes
    const db = firebase.firestore();
    const docRef = db.collection('artifacts').doc(appId).collection('users').doc(userId).collection('notes').doc(currentInfoVideoId);
    
    try {
        await docRef.set({
            uploader: uploaderInput.value.trim(),
            info: infoTextarea.value.trim(),
            comment: commentTextarea.value.trim(),
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge: true });
        showMessage("노트가 저장되었습니다!", 'ok');
        closeInfoModal();
    } catch(e) {
        console.error("Failed to save note:", e);
        showMessage("노트 저장 실패: " + e.message, 'error');
    }
  }

  // 버스터콜 기능
  function busterCall(videoId) {
    if (!authed) {
      showMessage("로그인되지 않았습니다. 잠시 후 다시 시도해주세요.", 'error');
      return;
    }
    try {
      const db = firebase.firestore();
      const ref = db.collection('artifacts').doc(appId).collection('public')
        .doc('data').collection('playback_state').doc('main_state');
      
      ref.set({
        videoId: videoId,
        timestamp: 0,
        lastUpdatedBy: clientId,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      }, { merge: true });

      showMessage("모든 사용자에게 버스터콜을 보냈습니다!", 'ok');
      saveBusterCallState();

      // Show buster call overlay
      busterCallOverlay.classList.add('show');
      setTimeout(() => {
        busterCallOverlay.classList.remove('show');
      }, 3000);

      player.loadVideoById(videoId, 0);
      player.playVideo();
      updatePlayingSong(videoId); // Update song info after buster call
    } catch (e) {
      console.error("버스터콜 실패:", e);
      showMessage("버스터콜에 실패했습니다. " + e.message, 'error');
    }
  }

  function getVideoId(url) {
    if (url.length === 11 && !url.includes(' ')) {
      return url;
    }
    url = url.replace('music.youtube.com', 'www.youtube.com');
    const regex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/i;
    const match = url.match(regex);
    return (match && match[1]) ? match[1] : null;
  }

  async function fetchVideoDetails(videoId) {
    const apiUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet&id=${videoId}&key=${YOUTUBE_API_KEY}`;
    const response = await fetch(apiUrl);
    if (!response.ok) {
        throw new Error(`API Error: ${response.status} ${response.statusText}`);
    }
    const data = await response.json();
    if (data.items && data.items.length > 0) {
      const snippet = data.items[0].snippet;
      return {
        title: snippet.title,
        artist: snippet.channelTitle
      };
    } else {
      throw new Error("Failed to find video information.");
    }
  }

  function playVideo(index) {
    const playlistToPlay = globalState.isShuffled ? globalState.shuffledPlaylist : globalState.playlist;

    if (playlistToPlay.length === 0) {
      showMessage("재생목록이 비어있습니다. 먼저 곡을 추가해주세요.", 'info');
      return;
    }

    if (index >= playlistToPlay.length) {
      index = 0;
    } else if (index < 0) {
      index = playlistToPlay.length - 1;
    }

    const nextSong = playlistToPlay[index];
    if (nextSong) {
      try {
        if (player) {
          player.loadVideoById(nextSong.videoId, 0);
          player.playVideo();
          updatePlayingSong(nextSong.videoId);
        }
      } catch (e) {
        console.error("Error playing video:", e);
      }
    }
  }

  function playNext() {
    const playlistToPlay = globalState.isShuffled ? globalState.shuffledPlaylist : globalState.playlist;
    if (playlistToPlay.length === 0) {
      return;
    }
    
    let nextIndex = (globalState.currentPlayingIndex + 1) % playlistToPlay.length;
    playVideo(nextIndex);
  }

  function playPrev() {
    const playlistToPlay = globalState.isShuffled ? globalState.shuffledPlaylist : globalState.playlist;
    if (playlistToPlay.length === 0) {
      return;
    }
    
    let prevIndex = (globalState.currentPlayingIndex - 1 + playlistToPlay.length) % playlistToPlay.length;
    playVideo(prevIndex);
  }

  function togglePlayerVisibility() {
    globalState.isPlayerVisible = !globalState.isPlayerVisible;
    if (globalState.isPlayerVisible) {
      playerContainer.style.height = 'auto';
      togglePlayerBtn.textContent = '화면 숨기기';
      playerContainer.style.opacity = '1';
    } else {
      playerContainer.style.height = '0';
      togglePlayerBtn.textContent = '화면 보기';
      playerContainer.style.opacity = '0';
    }
  }

  function wireUI() {
    addBtn.addEventListener('click', async () => {
      if (isManuallyAdding) {
        const url = (urlInput.value || '').trim();
        const videoId = getVideoId(url);
        const title = manualTitleInput.value.trim();
        const artist = manualArtistInput.value.trim();

        if (!videoId) {
            showMessage("유효한 유튜브 링크 또는 ID를 입력해주세요.", 'error');
            return;
        }
        if (!title || !artist) {
            showMessage("제목과 아티스트를 모두 입력해주세요.", 'error');
            return;
        }
        
        const newPlaylist = [...globalState.playlist, {
          title: title,
          artist: artist,
          videoId: videoId
        }];
        updatePlaylist(newPlaylist);
        urlInput.value = '';
        manualTitleInput.value = '';
        manualArtistInput.value = '';
        isManuallyAdding = false;
        manualInputDiv.style.display = 'none';
        addBtn.textContent = '추가';
        return;
      }
      
      const url = (urlInput.value || '').trim();
      const videoId = getVideoId(url);
      if (!videoId) {
        showMessage("유효한 유튜브 링크 또는 ID를 입력해주세요.", 'error');
        return;
      }
      addBtn.textContent = '불러오는 중...';
      addBtn.disabled = true;

      try {
        const videoDetails = await fetchVideoDetails(videoId);
        const newPlaylist = [...globalState.playlist, {
          title: videoDetails.title,
          artist: videoDetails.channelTitle,
          videoId: videoId
        }];
        updatePlaylist(newPlaylist);
        urlInput.value = '';
        manualInputDiv.style.display = 'none';
        isManuallyAdding = false;
      } catch (e) {
        console.error("동영상 정보를 가져오는 데 실패했습니다: " + e.message, e);
        if (e.message.includes('403')) {
            showMessage("API 키 사용량 초과 또는 유효하지 않은 키입니다. 수동으로 제목과 아티스트를 입력해주세요.", 'error');
            isManuallyAdding = true;
            manualInputDiv.style.display = 'block';
            addBtn.textContent = '수동 추가';
        } else {
            showMessage("동영상 정보를 가져오는 데 실패했습니다: " + e.message, 'error');
        }
      } finally {
        addBtn.disabled = false;
        if (!isManuallyAdding) {
            addBtn.textContent = '추가';
        }
      }
    });
    
    shuffleBtn.addEventListener('click', () => {
      if (globalState.isShuffled) {
        globalState.isShuffled = false;
        globalState.shuffledPlaylist = [];
        shuffleBtn.textContent = '셔플';
        showMessage("재생목록 정렬");
      } else {
        if (globalState.playlist.length === 0) {
          showMessage("재생목록이 비어있습니다. 먼저 곡을 추가해주세요.", 'info');
          return;
        }
        globalState.isShuffled = true;
        globalState.shuffledPlaylist = [...globalState.playlist].sort(() => Math.random() - 0.5);
        shuffleBtn.textContent = '정렬';
        showMessage("재생목록 셔플");
      }
      renderList();
      playVideo(0);
    });

    busterCallToggleBtn.addEventListener('click', () => {
        globalState.isBusterCallMode = !globalState.isBusterCallMode;
        busterCallToggleBtn.classList.toggle('active', globalState.isBusterCallMode);
        busterCallToggleBtn.textContent = "버스터콜";
        showMessage(globalState.isBusterCallMode ? "버스터콜 모드가 활성화되었습니다. 재생목록을 눌러 버스터콜을 시작하세요." : "버스터콜 모드가 비활성화되었습니다.");
    });
    
    prevSongBtn.addEventListener('click', () => {
        playPrev();
        showMessage("이전 곡으로 넘어갑니다.");
    });

    nextSongBtn.addEventListener('click', () => {
        playNext();
        showMessage("다음 곡으로 넘어갑니다.");
    });
    
    togglePlayerBtn.addEventListener('click', togglePlayerVisibility);

    modalCloseBtn.addEventListener('click', closeInfoModal);
    saveInfoBtn.addEventListener('click', saveInfo);

    window.addEventListener('click', (event) => {
      if (event.target === infoModal) {
        closeInfoModal();
      }
    });
  }
  
  // Expose the function to the global scope for the button to work
  window.openInfoModal = openInfoModal;

  window.onload = function() {
    boot();
  };
</script>
</body>
</html>
