<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>사랑방 띵곡 플레이어</title>
  <style>
    body { font-family: system-ui, -apple-apple-system, Segoe UI, Roboto, sans-serif; background: #111; color: #eee; margin: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
    .wrap { max-width: 900px; margin: 24px auto; padding: 0 16px; width: 100%; }
    .card { border: 1px solid #444; border-radius: 10px; padding: 16px; margin: 12px 0; background: #222; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
    .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .btn { background: #63b3ed; color: #fff; border: 0; border-radius: 999px; padding: .6rem 1rem; cursor: pointer; transition: background 0.2s; }
    .btn:hover { background: #4299e1; }
    .btn-toggle { background: #555; }
    .btn-toggle.active { background: #38b2ac; }
    .muted { color: #a0aec0; }
    input { background: #1f2937; color: #eee; border: 1px solid #374151; border-radius: 8px; padding: .55rem .7rem; flex: 1; min-width: 220px; outline: none; transition: border-color 0.2s; }
    input:focus { border-color: #63b3ed; }
    .item { display: flex; justify-content: space-between; align-items: center; padding: .5rem .6rem; border-bottom: 1px solid #2f3743; cursor: pointer; transition: background 0.2s; }
    .item:hover { background: #2a3340; }
    .item:last-child { border-bottom: none; }
    .item .delete-btn { background: none; border: none; color: #fc8181; cursor: pointer; font-size: 1.2em; line-height: 1; margin-left: 10px; opacity: 0.7; transition: opacity 0.2s; }
    .item .delete-btn:hover { opacity: 1; }
    .video-player { aspect-ratio: 16 / 9; width: 100%; max-width: 800px; margin: 8px auto; border-radius: 8px; overflow: hidden; position: relative; }
    .main-title { text-align: center; }
    .sub-title { text-align: center; font-size: 0.9em; margin-top: -15px; color: #a0aec0; }
    .message-box { display: none; background: #2d3748; color: #fff; padding: 12px; border-radius: 8px; text-align: center; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000; }
  </style>
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore-compat.js"></script>
  <!-- YouTube iFrame Player API -->
  <script src="https://www.youtube.com/iframe_api"></script>
</head>
<body>
<div id="message-box" class="message-box"></div>
<div class="wrap">
  <div class="main-title">
    <h1 id="title-text">
      <span id="prev-song-trigger">사</span>랑방 띵곡 플레이<span id="next-song-trigger">어</span>
    </h1>
    <p class="sub-title">작가님들의 띵곡을 추천해주세요</p>
  </div>
  
  <div class="card">
    <div class="video-player">
      <div id="player"></div>
    </div>
    
    <div class="row" style="margin-top:10px">
      <input id="url" placeholder="유튜브 링크 또는 ID를 붙여넣기"/>
      <button id="add" class="btn">추가</button>
    </div>
    <div id="manual-input" style="display:none; margin-top: 10px;">
      <div class="row">
        <input id="manualTitle" placeholder="제목을 수동으로 입력해주세요"/>
      </div>
      <div class="row" style="margin-top: 10px;">
        <input id="manualArtist" placeholder="아티스트를 수동으로 입력해주세요"/>
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <button id="burstCallToggle" class="btn btn-toggle">버스트콜 모드 (비활성화)</button>
    </div>

    <div id="playlist" class="card" style="margin:10px 0 0 0">
      <div class="muted">재생목록이 비어있습니다.</div>
    </div>
  </div>
</div>

<script>
  /* YouTube Data API 키 */
  const YOUTUBE_API_KEY = "AIzaSyB2GymrywkBYx4Mbt_xHNiYEV44MbfKY2w";
  
  /* Firebase 설정 */
  const firebaseConfig = {
    apiKey: "AIzaSyDz6xGJNKXinG5rREjdrPz7toIYGZXzilU",
    authDomain: "sarangbangmusicplaylist.firebaseapp.com",
    projectId: "sarangbangmusicplaylist",
    storageBucket: "sarangbangmusicplaylist.appspot.com",
    messagingSenderId: "193412502606",
    appId: "1:193412502606:web:0f7f9ddbef1ee6711d1ff",
    measurementId: "G-L14GH3BHYD"
  };

  /* 요소 */
  const urlInput = document.getElementById('url');
  const addBtn = document.getElementById('add');
  const listEl = document.getElementById('playlist');
  const messageBox = document.getElementById('message-box');
  const manualInputDiv = document.getElementById('manual-input');
  const manualTitleInput = document.getElementById('manualTitle');
  const manualArtistInput = document.getElementById('manualArtist');
  const burstCallToggleBtn = document.getElementById('burstCallToggle');
  const prevSongTrigger = document.getElementById('prev-song-trigger');
  const nextSongTrigger = document.getElementById('next-song-trigger');

  /* 상태 */
  const appId = 'default-app-id';
  const clientId = (crypto && crypto.randomUUID) ? crypto.randomUUID() : String(Math.random());
  const globalState = {
    playlist: [],
    videoId: '',
    timestamp: 0,
    lastUpdatedBy: null,
    currentPlayingIndex: -1,
    isBurstCallMode: false,
  };
  let authed=false, player, playerReady=false, isManuallyAdding=false;
  let lastPlaybackVersion = 0; // 최신 버전만 적용

  function showMessage(message, type='info'){
    messageBox.textContent = message;
    messageBox.style.background = type==='error' ? '#fc8181' : '#2d3748';
    messageBox.style.display = 'block';
    setTimeout(()=>{ messageBox.style.display='none'; }, 3000);
  }

  /* Firebase 부팅 */
  async function boot(){
    try { firebase.initializeApp(firebaseConfig); }
    catch(e){ console.error("Firebase initialization failed:", e.message); return; }

    try { await firebase.auth().signInAnonymously(); authed=true; }
    catch(e){ console.error("Authentication failed:", e.message); return; }

    const db = firebase.firestore();
    try{
      const pingRef = db.collection('artifacts').doc(appId).collection('public').doc('_ping');
      await pingRef.set({ pong:true, by:clientId, at:new Date() }, { merge:true });
    }catch(e){ console.error("Firestore write failed:", e.message); }

    startRealtime();
    wireUI();
  }
  
  /* YouTube API */
  function onYouTubeIframeAPIReady() {
    playerReady = true;
    player = new YT.Player('player', {
      height: '100%', width: '100%', videoId: '',
      playerVars: { autoplay: 0, controls: 1, disablekb: 1, fs: 0, iv_load_policy: 3, modestbranding: 1, rel: 0, showinfo: 0 },
      events: { onStateChange: onPlayerStateChange, onReady: onPlayerReady }
    });
  }
  window.onYouTubeIframeAPIReady = onYouTubeIframeAPIReady;
  
  function onPlayerReady(){
    // 자동 랜덤 재생 제거. 제어는 스냅샷/사용자에 의해 결정.
  }

  function onPlayerStateChange(event){
    switch (event.data) {
      case YT.PlayerState.ENDED:
        // 일반 모드에서만 다음 곡 자동
        if (!globalState.isBurstCallMode) playRandomVideo();
        break;

      case YT.PlayerState.PLAYING: {
        const currentVideoId = player.getVideoData().video_id;
        if (currentVideoId && currentVideoId.length === 11) {
          globalState.videoId = currentVideoId;
          globalState.timestamp = player.getCurrentTime();
          // 버스트콜 모드가 아닐 때만 재생 상태 저장
          if (!globalState.isBurstCallMode) savePlaybackState();
        }
        break;
      }

      case YT.PlayerState.PAUSED:
        globalState.timestamp = player.getCurrentTime();
        if (!globalState.isBurstCallMode) savePlaybackState();
        break;
    }
  }

  /* 저장 */
  let playbackSaveTimer=null, playlistSaveTimer=null;

  function savePlaybackState(){
    if(!authed) return;
    if(playbackSaveTimer) clearTimeout(playbackSaveTimer);
    playbackSaveTimer = setTimeout(async ()=>{
      try{
        const db = firebase.firestore();
        const ref = db.collection('artifacts').doc(appId).collection('public')
                      .doc('data').collection('playback_state').doc('main_state');
        const version = Date.now();
        await ref.set({
          videoId: globalState.videoId,
          timestamp: globalState.timestamp,
          version,                     // 버전 포함
          lastUpdatedBy: clientId,
          updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge:true });
      }catch(e){ console.error("Failed to save playback state:", e.message); }
    }, 300);
  }

  function savePlaylistState(){
    if(!authed) return;
    if(playlistSaveTimer) clearTimeout(playlistSaveTimer);
    playlistSaveTimer = setTimeout(async ()=>{
      try{
        const db = firebase.firestore();
        const ref = db.collection('artifacts').doc(appId).collection('public')
                      .doc('data').collection('playlist_state').doc('main_playlist');
        await ref.set({
          playlist: globalState.playlist,
          lastUpdatedBy: clientId,
          updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge:true });
      }catch(e){ console.error("Failed to save playlist state:", e.message); }
    }, 300);
  }

  function startRealtime(){
    const db = firebase.firestore();

    // 재생 상태 실시간
    const playbackRef = db.collection('artifacts').doc(appId).collection('public')
                          .doc('data').collection('playback_state').doc('main_state');
    playbackRef.onSnapshot(snap=>{
      if(!snap.exists) return;
      const state = snap.data() || {};
      const v = Number(state.version || 0);
      if (!v || v <= lastPlaybackVersion) return; // 최신만 적용
      lastPlaybackVersion = v;

      try{
        if(playerReady && state.videoId){
          player.loadVideoById(state.videoId);
          player.seekTo(Number(state.timestamp)||0, true);
        }
      }catch(e){ console.error("Playback sync error:", e); }
    }, err=>console.error("Playback subscription error:", err.message));

    // 재생목록 실시간
    const playlistRef = db.collection('artifacts').doc(appId).collection('public')
                          .doc('data').collection('playlist_state').doc('main_playlist');
    playlistRef.onSnapshot(snap=>{
      if(!snap.exists){ savePlaylistState(); return; }
      const d = snap.data() || {};
      if (Array.isArray(d.playlist)) {
        globalState.playlist = d.playlist;
        renderList();
      }
    }, err=>console.error("Playlist subscription error:", err.message));
  }

  function updatePlaylist(newPlaylist){
    globalState.playlist = newPlaylist;
    renderList();
    savePlaylistState();
  }

  /* 렌더/플레이 */
  function renderList(){
    listEl.innerHTML = '';
    if(!globalState.playlist.length){
      listEl.innerHTML = '<div class="muted">재생목록이 비어있습니다.</div>';
      return;
    }
    globalState.playlist.forEach((item, index)=>{
      const div = document.createElement('div');
      div.className = 'item';
      div.dataset.videoId = item.videoId;
      div.innerHTML = `<span>${item.artist} - ${item.title}</span><button class="delete-btn" data-index="${index}">&#x2715;</button>`;

      // 삭제
      div.querySelector('.delete-btn').addEventListener('click', (e)=>{
        e.stopPropagation();
        const i = parseInt(e.target.dataset.index, 10);
        const next = [...globalState.playlist];
        next.splice(i,1);
        updatePlaylist(next);
      });

      // 클릭 재생 / 버스트콜
      div.addEventListener('click', ()=>{
        const videoId = div.dataset.videoId;
        if(globalState.isBurstCallMode){
          burstCall(videoId);
        }else{
          if (player) {
            player.loadVideoById(videoId, 0);
            player.playVideo();
          }
          showMessage("해당 곡을 재생합니다.");
        }
      });

      listEl.appendChild(div);
    });
  }

  // 버스트콜: DB만 업데이트. 재생은 스냅샷이 처리.
  function burstCall(videoId){
    if(!authed){ showMessage("로그인되지 않았습니다.", 'error'); return; }
    try{
      const db = firebase.firestore();
      const ref = db.collection('artifacts').doc(appId).collection('public')
        .doc('data').collection('playback_state').doc('main_state');
      ref.set({
        videoId,
        timestamp: 0,
        version: Date.now(), // 단조 증가 버전
        lastUpdatedBy: clientId,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      }, { merge:true });
      showMessage("버스트콜 전파 완료.");
      // 로컬 즉시 재생 금지
    }catch(e){
      console.error("버스트콜 실패:", e);
      showMessage("버스트콜 실패: " + e.message, 'error');
    }
  }

  function getVideoId(input){
    if(!input) return null;
    const s = input.trim();
    if(/^[A-Za-z0-9_-]{11}$/.test(s)) return s; // 순수 ID
    const url = s.replace('music.youtube.com','www.youtube.com');
    const m = url.match(/(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/i);
    return m ? m[1] : null;
  }

  async function fetchVideoDetails(videoId){
    const apiUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet&id=${videoId}&key=${YOUTUBE_API_KEY}`;
    const res = await fetch(apiUrl);
    if(!res.ok) throw new Error(`API Error: ${res.status} ${res.statusText}`);
    const data = await res.json();
    if(!data.items?.length) throw new Error("Failed to find video information.");
    const sn = data.items[0].snippet;
    return { title: sn.title, artist: sn.channelTitle };
  }

  function playVideo(index){
    if(!globalState.playlist.length){ showMessage("재생목록이 비어있습니다.", 'info'); return; }
    if(index >= globalState.playlist.length) index = 0;
    if(index < 0) index = globalState.playlist.length - 1;
    const nextSong = globalState.playlist[index];
    if(nextSong && player){
      try{
        player.loadVideoById(nextSong.videoId, 0);
        player.playVideo();
        globalState.currentPlayingIndex = index;
      }catch(e){ console.error("Error playing video:", e); }
    }
  }
  
  function playRandomVideo(){
    if(!globalState.playlist.length) return;
    const randomIndex = Math.floor(Math.random() * globalState.playlist.length);
    playVideo(randomIndex);
  }

  function playNext(){
    if(!globalState.playlist.length) return;
    const nextIndex = (globalState.currentPlayingIndex + 1) % globalState.playlist.length;
    playVideo(nextIndex);
  }

  function playPrev(){
    if(!globalState.playlist.length) return;
    const prevIndex = (globalState.currentPlayingIndex - 1 + globalState.playlist.length) % globalState.playlist.length;
    playVideo(prevIndex);
  }

  function wireUI(){
    // 추가 버튼
    addBtn.addEventListener('click', async ()=>{
      if(isManuallyAdding){
        const url = (urlInput.value || '').trim();
        const videoId = getVideoId(url);
        const title = manualTitleInput.value.trim();
        const artist = manualArtistInput.value.trim();
        if(!videoId) return showMessage("유효한 유튜브 링크 또는 ID를 입력해주세요.", 'error');
        if(!title || !artist) return showMessage("제목과 아티스트를 모두 입력해주세요.", 'error');
        updatePlaylist([...globalState.playlist, { title, artist, videoId }]);
        urlInput.value=''; manualTitleInput.value=''; manualArtistInput.value='';
        isManuallyAdding=false; manualInputDiv.style.display='none'; addBtn.textContent='추가';
        return;
      }

      const url = (urlInput.value || '').trim();
      const videoId = getVideoId(url);
      if(!videoId) return showMessage("유효한 유튜브 링크 또는 ID를 입력해주세요.", 'error');

      addBtn.textContent = '불러오는 중...'; addBtn.disabled = true;
      try{
        const meta = await fetchVideoDetails(videoId);
        updatePlaylist([...globalState.playlist, { title: meta.title, artist: meta.artist, videoId }]);
        urlInput.value = '';
      }catch(e){
        console.error("동영상 정보를 가져오지 못했습니다:", e);
        if(String(e.message).includes('403')){
          showMessage("API 제한. 수동 입력으로 전환합니다.", 'error');
          isManuallyAdding = true;
          manualInputDiv.style.display = 'block';
          addBtn.textContent = '수동 추가';
        }else{
          showMessage("동영상 정보 조회 실패: " + e.message, 'error');
        }
      }finally{
        addBtn.disabled = false;
        if(!isManuallyAdding) addBtn.textContent = '추가';
      }
    });

    // 버스트콜 토글
    burstCallToggleBtn.addEventListener('click', ()=>{
      globalState.isBurstCallMode = !globalState.isBurstCallMode;
      burstCallToggleBtn.classList.toggle('active', globalState.isBurstCallMode);
      burstCallToggleBtn.textContent = globalState.isBurstCallMode ? "버스트콜 모드 (활성화)" : "버스트콜 모드 (비활성화)";
      showMessage(globalState.isBurstCallMode ? "버스트콜 모드 활성화. 목록 클릭 시 전파." : "버스트콜 모드 비활성화. 로컬 재생만.");
    });

    // 이전/다음
    prevSongTrigger.addEventListener('click', ()=>{ playPrev(); showMessage("이전 곡"); });
    nextSongTrigger.addEventListener('click', ()=>{ playNext(); showMessage("다음 곡"); });
  }

  // 시작
  window.onload = function(){ boot(); };
</script>
</body>
</html>
