<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>사랑방 띵곡 플레이어</title>
  <style>
    body { font-family: system-ui, -apple-apple-system, Segoe UI, Roboto, sans-serif; background: #111; color: #eee; margin: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
    .wrap { max-width: 900px; margin: 24px auto; padding: 0 16px; width: 100%; }
    .card { border: 1px solid #444; border-radius: 10px; padding: 16px; margin: 12px 0; background: #222; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
    .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .btn { background: #63b3ed; color: #fff; border: 0; border-radius: 999px; padding: .6rem 1rem; cursor: pointer; transition: background 0.2s; }
    .btn:hover { background: #4299e1; }
    .ok { color: #81e6d9; }
    .fail { color: #fc8181; }
    .muted { color: #a0aec0; }
    input { background: #1f2937; color: #eee; border: 1px solid #374151; border-radius: 8px; padding: .55rem .7rem; flex: 1; min-width: 220px; outline: none; transition: border-color 0.2s; }
    input:focus { border-color: #63b3ed; }
    .item { display: flex; justify-content: space-between; align-items: center; padding: .5rem .6rem; border-bottom: 1px solid #2f3743; cursor: default; }
    .item:hover { background: #2a3340; }
    .item:last-child { border-bottom: none; }
    .item .delete-btn { background: none; border: none; color: #fc8181; cursor: pointer; font-size: 1.2em; line-height: 1; margin-left: 10px; opacity: 0.7; transition: opacity 0.2s; }
    .item .delete-btn:hover { opacity: 1; }
    .video-player { aspect-ratio: 16 / 9; width: 100%; max-width: 800px; margin: 8px auto; border-radius: 8px; overflow: hidden; position: relative; }
    .main-title { text-align: center; }
    .sub-title { text-align: center; font-size: 0.9em; margin-top: -15px; color: #a0aec0; }
    .message-box { display: none; background: #2d3748; color: #fff; padding: 12px; border-radius: 8px; text-align: center; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000; }
    .playback-controls { display: flex; align-items: center; gap: 8px; margin-top: 10px; }
    .playback-controls .btn { padding: 0.5rem 1rem; }
    
    #player { pointer-events: auto; }

    /* 유튜브 전체를 덮는 투명한 오버레이 */
    .video-overlay-unclickable {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.1); /* 투명도를 낮춰서 투명하게 만듦 */
      pointer-events: auto; /* 이 부분이 중요합니다. 이제 클릭을 막습니다. */
      opacity: 1;
      transition: opacity 0.3s ease-in-out;
      z-index: 10;
    }
    .video-overlay-unclickable.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    /* 중앙에 뚫린 네모 영역 */
    .video-overlay-hole {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100px; /* 네모 크기 조절 */
      height: 100px;
      pointer-events: auto; /* 이 영역만 클릭 활성화 */
      cursor: pointer;
      z-index: 11; /* unclickable 오버레이보다 위로 */
      border-radius: 10px;
    }
    
    .video-overlay-hole.hidden {
      pointer-events: none;
    }
  </style>
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore-compat.js"></script>
  <!-- YouTube iFrame Player API -->
  <script src="https://www.youtube.com/iframe_api"></script>
</head>
<body>
<div id="message-box" class="message-box"></div>
<div class="wrap">
  <div class="main-title">
    <h1 id="title-text">
      <span id="prev-song-trigger">사</span>랑방 띵곡 플레이<span id="next-song-trigger">어</span>
    </h1>
    <p class="sub-title">작가님들의 띵곡을 추천해주세요</p>
  </div>
  
  <div class="card">
    <div class="video-player">
      <div id="player"></div>
      <!-- 오버레이 추가 -->
      <div id="video-overlay-unclickable" class="video-overlay-unclickable"></div>
      <div id="video-overlay-hole" class="video-overlay-hole"></div>
    </div>
    
    <div class="row" style="margin-top:10px">
      <input id="url" placeholder="유튜브 링크 또는 ID를 붙여넣기"/>
      <button id="add" class="btn">추가</button>
    </div>
    <div id="manual-input" style="display:none; margin-top: 10px;">
      <div class="row">
        <input id="manualTitle" placeholder="제목을 수동으로 입력해주세요"/>
      </div>
      <div class="row" style="margin-top: 10px;">
        <input id="manualArtist" placeholder="아티스트를 수동으로 입력해주세요"/>
      </div>
    </div>
    
    <div class="playback-controls">
      <button id="volumeBtn" class="btn">
        볼륨
      </button>
      <input type="range" id="volumeSlider" min="0" max="100" value="100">
    </div>

    <div id="playlist" class="card" style="margin:10px 0 0 0">
      <div class="muted">재생목록이 비어있습니다.</div>
    </div>
  </div>
</div>

<script>
  // --- 중요: 유튜브 API 키를 여기에 입력하세요 ---
  // 이 오류는 API 키 사용량이 초과되었거나 키가 잘못되었을 때 발생합니다.
  // 직접 발급받은 API 키가 있다면 아래 변수의 값을 교체해주세요.
  // https://console.cloud.google.com/apis/credentials
  const YOUTUBE_API_KEY = "AIzaSyB2GymrywkBYx4Mbt_xHNiYEV44MbfKY2w";
  
  // Firebase configuration
  const firebaseConfig = {
    apiKey: "AIzaSyDz6xGJNKXinG5rREjdrPz7toIYGZXzilU",
    authDomain: "sarangbangmusicplaylist.firebaseapp.com",
    projectId: "sarangbangmusicplaylist",
    storageBucket: "sarangbangmusicplaylist.apppt.com",
    messagingSenderId: "193412502606",
    appId: "1:193412502606:web:0f7f9ddbef1ee6711d1ff",
    measurementId: "G-L14GH3BHYD"
  };

  // ----- elements -----
  const urlInput = document.getElementById('url');
  const addBtn = document.getElementById('add');
  const listEl = document.getElementById('playlist');
  const messageBox = document.getElementById('message-box');
  const volumeSlider = document.getElementById('volumeSlider');
  const volumeBtn = document.getElementById('volumeBtn');
  const videoOverlayUnclickable = document.getElementById('video-overlay-unclickable');
  const videoOverlayHole = document.getElementById('video-overlay-hole');
  const manualInputDiv = document.getElementById('manual-input');
  const manualTitleInput = document.getElementById('manualTitle');
  const manualArtistInput = document.getElementById('manualArtist');
  
  const prevSongTrigger = document.getElementById('prev-song-trigger');
  const nextSongTrigger = document.getElementById('next-song-trigger');

  // ----- state/guards -----
  const appId = 'default-app-id';
  const clientId = (crypto && crypto.randomUUID) ? crypto.randomUUID() : String(Math.random());
  
  // Centralized state management
  const globalState = {
    playlist: [],
    videoId: '',
    timestamp: 0,
    lastUpdatedBy: null,
    lastVolume: 100,
    currentPlayingIndex: -1,
  };

  let authed = false;
  let player;
  let playerReady = false;
  let isManuallyAdding = false;

  function showMessage(message, type = 'info') {
    messageBox.textContent = message;
    if (type === 'error') {
      messageBox.style.background = '#fc8181';
    } else {
      messageBox.style.background = '#2d3748';
    }
    messageBox.style.display = 'block';
    setTimeout(() => {
      messageBox.style.display = 'none';
    }, 3000);
  }

  function showOverlay() {
    videoOverlayUnclickable.classList.remove('hidden');
    videoOverlayHole.classList.remove('hidden');
  }

  function hideOverlay() {
    videoOverlayUnclickable.classList.add('hidden');
    videoOverlayHole.classList.add('hidden');
  }

  // ----- Firebase initialization + anonymous login + diagnostics -----
  async function boot() {
    try {
      firebase.initializeApp(firebaseConfig);
      console.log("Firebase initialized successfully");
    } catch (e) {
      console.error("Firebase initialization failed: " + e.message);
      return;
    }

    try {
      await firebase.auth().signInAnonymously();
      authed = true;
      console.log("Anonymous sign-in successful, user ID:", firebase.auth().currentUser.uid);
    } catch (e) {
      console.error("Authentication failed: " + e.message);
      return;
    }

    // Firestore ping
    const db = firebase.firestore();
    try {
      const pingRef = db.collection('artifacts').doc(appId).collection('public').doc('_ping');
      await pingRef.set({ pong: true, by: clientId, at: new Date() }, { merge: true });
      console.log("Firestore write successful");
    } catch (e) {
      console.error("Firestore write failed: " + e.message);
    }

    startRealtime();
    wireUI();
  }

  // Called when the YouTube iFrame Player API is loaded
  function onYouTubeIframeAPIReady() {
    playerReady = true;
    player = new YT.Player('player', {
      height: '100%',
      width: '100%',
      videoId: '',
      playerVars: {
        'autoplay': 0, 
        'controls': 1,
        'disablekb': 1,
        'fs': 0,
        'iv_load_policy': 3,
        'modestbranding': 1,
        'rel': 0,
        'showinfo': 0
      },
      events: {
        'onStateChange': onPlayerStateChange,
        'onReady': onPlayerReady
      }
    });
  }
  
  // Called when the YouTube player is ready
  function onPlayerReady(event) {
    console.log('YouTube Player is ready.');
    if (globalState.playlist.length > 0) {
        showOverlay();
    }
  }

  // Called when the YouTube player state changes
  function onPlayerStateChange(event) {
    console.log('Player state changed:', event.data);
    switch (event.data) {
        case YT.PlayerState.ENDED:
            playRandomVideo();
            showOverlay();
            break;
        case YT.PlayerState.PLAYING:
            // 동영상 ID가 로드된 후에만 상태를 업데이트하고 저장합니다.
            const currentVideoId = player.getVideoData().video_id;
            if (currentVideoId && currentVideoId.length === 11) {
                globalState.videoId = currentVideoId;
                globalState.timestamp = player.getCurrentTime();
                savePlaybackState();
            }
            break;
        case YT.PlayerState.PAUSED:
            globalState.timestamp = player.getCurrentTime();
            savePlaybackState();
            showOverlay();
            break;
    }
  }

  // ----- save/sync functions -----

  // 재생 상태(videoId, timestamp)만 저장하는 함수
  let playbackSaveTimer = null;
  function savePlaybackState() {
    if (!authed) return;
    if (playbackSaveTimer) clearTimeout(playbackSaveTimer);
    playbackSaveTimer = setTimeout(async () => {
      try {
        const db = firebase.firestore();
        const ref = db.collection('artifacts').doc(appId).collection('public')
          .doc('data').collection('playback_state').doc('main_state');
        
        await ref.set({
          videoId: globalState.videoId,
          timestamp: globalState.timestamp,
          lastUpdatedBy: clientId,
          updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge: true });

        console.log('Playback state saved successfully.');
      } catch (e) {
        console.error("Failed to save playback state: " + e.message);
      }
    }, 300);
  }

  // 재생목록(playlist)만 저장하는 함수
  let playlistSaveTimer = null;
  function savePlaylistState() {
    if (!authed) return;
    if (playlistSaveTimer) clearTimeout(playlistSaveTimer);
    playlistSaveTimer = setTimeout(async () => {
      try {
        const db = firebase.firestore();
        const ref = db.collection('artifacts').doc(appId).collection('public')
          .doc('data').collection('playlist_state').doc('main_playlist');

        await ref.set({
          playlist: globalState.playlist,
          lastUpdatedBy: clientId,
          updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge: true });

        console.log('Playlist state saved successfully.');
      } catch (e) {
        console.error("Failed to save playlist state: " + e.message);
      }
    }, 300);
  }

  function startRealtime() {
    const db = firebase.firestore();

    // 재생 상태 실시간 동기화
    const playbackRef = db.collection('artifacts').doc(appId).collection('public')
      .doc('data').collection('playback_state').doc('main_state');
    
    playbackRef.onSnapshot(async (snap) => {
      if (!snap.exists) return;
      const state = snap.data() || {};
      
      if (state.lastUpdatedBy === clientId) return;

      try {
        if (playerReady && state.videoId && globalState.videoId !== state.videoId) {
            player.loadVideoById(state.videoId);
            player.seekTo(state.timestamp, true);
        }
      } catch (e) {
        console.error("Playback sync error:", e);
      }
    }, (err) => { console.error("Playback subscription error: " + err.message); });

    // 재생 목록 실시간 동기화
    const playlistRef = db.collection('artifacts').doc(appId).collection('public')
      .doc('data').collection('playlist_state').doc('main_playlist');

    playlistRef.onSnapshot(async (snap) => {
      if (!snap.exists) {
        savePlaylistState();
        return;
      }
      const playlistData = snap.data() || {};
      if (playlistData.lastUpdatedBy === clientId) return;
      
      globalState.playlist = Array.isArray(playlistData.playlist) ? playlistData.playlist : [];
      renderList();
    }, (err) => { console.error("Playlist subscription error: " + err.message); });
  }

  // Updates the playlist in the global state and triggers a save
  function updatePlaylist(newPlaylist) {
    globalState.playlist = newPlaylist;
    renderList();
    savePlaylistState();
  }

  // ----- UI/player -----
  function renderList() {
    listEl.innerHTML = '';
    if (!globalState.playlist.length) {
      listEl.innerHTML = '<div class="muted">재생목록이 비어있습니다.</div>';
      showOverlay();
      return;
    }
    
    globalState.playlist.forEach((item, index) => {
      const div = document.createElement('div');
      div.className = 'item';
      div.innerHTML = `<span>${item.artist} - ${item.title}</span><button class="delete-btn" data-index="${index}">&#x2715;</button>`;
      
      div.querySelector('.delete-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        const index = parseInt(e.target.dataset.index, 10);
        const newPlaylist = [...globalState.playlist];
        newPlaylist.splice(index, 1);
        updatePlaylist(newPlaylist);
      });
      
      listEl.appendChild(div);
    });
    
    if (globalState.playlist.length > 0 && (!player || !player.getVideoData())) {
        playRandomVideo();
        hideOverlay();
    } else {
        showOverlay();
    }
  }

  // 수정: 순수 ID와 URL을 모두 처리하도록 로직 변경
  function getVideoId(url) {
    // 1. 먼저 순수 11자리 ID인지 확인
    if (url.length === 11 && !url.includes(' ')) {
      return url;
    }
    // 2. 아니면 기존의 URL 정규식 검사 수행
    url = url.replace('music.youtube.com', 'www.youtube.com');
    const regex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/i;
    const match = url.match(regex);
    return (match && match[1]) ? match[1] : null;
  }

  async function fetchVideoDetails(videoId) {
    const apiUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet&id=${videoId}&key=${YOUTUBE_API_KEY}`;
    const response = await fetch(apiUrl);
    if (!response.ok) {
        // Handle API errors gracefully
        throw new Error(`API Error: ${response.status} ${response.statusText}`);
    }
    const data = await response.json();
    if (data.items && data.items.length > 0) {
      const snippet = data.items[0].snippet;
      return {
        title: snippet.title,
        // 수정: API 응답에서 channelTitle을 artist로 사용
        artist: snippet.channelTitle
      };
    } else {
      throw new Error("Failed to find video information.");
    }
  }

  function playVideo(index) {
    if (globalState.playlist.length === 0) {
      showMessage("재생목록이 비어있습니다. 먼저 곡을 추가해주세요.", 'info');
      return;
    }

    if (index >= globalState.playlist.length) {
      index = 0;
    } else if (index < 0) {
      index = globalState.playlist.length - 1;
    }

    const nextSong = globalState.playlist[index];
    if (nextSong) {
      try {
        if (player) {
          player.loadVideoById(nextSong.videoId, 0);
          player.playVideo();
          globalState.currentPlayingIndex = index;
        }
      } catch (e) {
        console.error("Error playing video:", e);
      }
    }
  }
  
  function playRandomVideo() {
    if (globalState.playlist.length === 0) {
        return;
    }
    let randomIndex = Math.floor(Math.random() * globalState.playlist.length);
    playVideo(randomIndex);
  }

  function playNext() {
    if (globalState.playlist.length === 0) {
      return;
    }
    
    let nextIndex = (globalState.currentPlayingIndex + 1) % globalState.playlist.length;
    playVideo(nextIndex);
  }

  function playPrev() {
    if (globalState.playlist.length === 0) {
      return;
    }
    
    let prevIndex = (globalState.currentPlayingIndex - 1 + globalState.playlist.length) % globalState.playlist.length;
    playVideo(prevIndex);
  }

  function wireUI() {
    addBtn.addEventListener('click', async () => {
      if (isManuallyAdding) {
        const url = (urlInput.value || '').trim();
        const videoId = getVideoId(url);
        const title = manualTitleInput.value.trim();
        const artist = manualArtistInput.value.trim();

        if (!videoId) {
            showMessage("유효한 유튜브 링크 또는 ID를 입력해주세요.", 'error');
            return;
        }
        if (!title || !artist) {
            showMessage("제목과 아티스트를 모두 입력해주세요.", 'error');
            return;
        }
        
        const newPlaylist = [...globalState.playlist, {
          title: title,
          artist: artist,
          videoId: videoId
        }];
        updatePlaylist(newPlaylist);
        urlInput.value = '';
        manualTitleInput.value = '';
        manualArtistInput.value = '';
        isManuallyAdding = false;
        manualInputDiv.style.display = 'none';
        addBtn.textContent = '추가';
        return;
      }
      
      const url = (urlInput.value || '').trim();
      const videoId = getVideoId(url);
      if (!videoId) {
        showMessage("유효한 유튜브 링크 또는 ID를 입력해주세요.", 'error');
        return;
      }
      addBtn.textContent = '불러오는 중...';
      addBtn.disabled = true;

      try {
        const videoDetails = await fetchVideoDetails(videoId);
        const newPlaylist = [...globalState.playlist, {
          title: videoDetails.title,
          // 수정: fetchVideoDetails에서 반환된 'artist' 필드를 사용
          artist: videoDetails.artist,
          videoId: videoId
        }];
        updatePlaylist(newPlaylist);
        urlInput.value = '';
        manualInputDiv.style.display = 'none';
        isManuallyAdding = false;
      } catch (e) {
        console.error("동영상 정보를 가져오는 데 실패했습니다: " + e.message, e);
        if (e.message.includes('403')) {
            showMessage("API 키 사용량 초과 또는 유효하지 않은 키입니다. 수동으로 제목과 아티스트를 입력해주세요.", 'error');
            isManuallyAdding = true;
            manualInputDiv.style.display = 'block';
            addBtn.textContent = '수동 추가';
        } else {
            showMessage("동영상 정보를 가져오는 데 실패했습니다: " + e.message, 'error');
        }
      } finally {
        addBtn.disabled = false;
        if (!isManuallyAdding) {
            addBtn.textContent = '추가';
        }
      }
    });

    volumeSlider.addEventListener('input', () => {
      if (playerReady) {
        player.setVolume(volumeSlider.value);
        if (player.isMuted()) {
          player.unMute();
        }
        globalState.lastVolume = volumeSlider.value;
      }
    });

    volumeBtn.addEventListener('click', () => {
      if (playerReady) {
        if (player.isMuted()) {
          player.unMute();
          player.setVolume(globalState.lastVolume);
          volumeSlider.value = globalState.lastVolume;
        } else {
          globalState.lastVolume = player.getVolume();
          player.mute();
          volumeSlider.value = 0;
        }
      }
    });

    // Central overlay click handler
    videoOverlayHole.addEventListener('click', () => {
        if (globalState.playlist.length > 0) {
            playRandomVideo();
            hideOverlay();
        } else {
            showMessage("재생목록이 비어있습니다. 먼저 곡을 추가해주세요.", 'info');
        }
    });
    
    // Previous song click handler
    prevSongTrigger.addEventListener('click', () => {
        playPrev();
        showMessage("이전 곡으로 넘어갑니다.");
    });

    // Next song click handler
    nextSongTrigger.addEventListener('click', () => {
        playNext();
        showMessage("다음 곡으로 넘어갑니다.");
    });
  }

  // ----- Start up -----
  window.onload = function() {
    boot();
  };
</script>
</body>
</html>
